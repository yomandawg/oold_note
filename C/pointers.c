/* 컴퓨터
휘발성 메모리
RAM(흔히 말하는 메모리)
속도가 매우 빠르다 - 랜덤 접근
=> 단번에 713호를 찾을 수 있는 반면 ROM은 1~713호까지 순차적으로 찾아야해
전원이 꺼지면 날라가기 때문에 중요 데이터는 하드에 보관

비휘발성 메모리
ROM
속도가 느리다 - 순차적 접근

CPU - 컴퓨터 연산 - register이라는 작은 메모리 공간
- 이곳에 값을 불러다 놓고 연산을 수행하게 된다
=> a+b 하기 위해 레지스터에 잠시 a, b의 값을 써놓는다
- 레지스터의 크기가 컴퓨터 상에서 연산이 실행되는 최소 단위: word
- 32비트 word(WORD), 64비트 word(DWORD)

모든 데이터들은 메모리 상에 특정한 공간이 저장 되어있다.
각 '방'(메모리의 특정 공간)에는 데이터들이 들어가게 되는 것
한 방의 크기를 1byte라고 생각할 때, int형 변수를 정의한다면 4칸을 차지하게 된다.
프로그램 작동 시 컴퓨터는 각 방에 있는 데이터를 필요로 하게 된다.
이 때 이 방들을 서로 구분하기 위해 각 방에 고유의 주소(address)를 붙여준다. - 아파트 호수같은 것

예) int a = 123; // 메모리 4칸을 차지한다
이 때, 0x152839가 이 방의 시작 주소라고 가정한다면(0x == 16진수)
그 주소부터 4칸(4byte)를 차지하여 123이라는 값을 저장하는 것

a = 10; 이라고 변수를 재선언하면 그 주소를 찾아 방 안의 데이터를 10으로 바꾸는 것

32비트에서 작동되는 컴퓨터들은 모두 주소값의 크기가 32비트(4바이트)
즉, 주소값이 0x00000000 ~ 0xFFFFFFFF 까지의 값을 가진다
2^32 == 16^8 == 4294967296bytes == 4GB
=> 32비트에서 RAM은 최대 4GB까지밖에 사용할 수 없다!
*/

/* 포인터
메모리 상에 위치한 특정 데이터(시작) 주소값을 보관하는 변수
포인터도 형이 있다!
int* p; // p라는 포인터가 int데이터를 가리킨다
p는 int형 데이터의 주소값을 저장하는 변수가 되는 것
*/

#include <stdio.h>

void test(); void test2(); void test3();

int main() {
    int a;
    a = 2;
    printf("%p\n", &a); // &a값을 16진수(p) 형태로 출력(앞의 0이 잘려서 출력; 주소값은 언제나 4바이트)
    // 1EF8D4 == 0x001EF8D4
    // int 변수 a는 메모리 상에서 0x001EF8D4를 시작으로 4바이트 공간을 차지하고 있을 것
    // &연산자 = 특정한 데이터의 메모리상 주소값

    test();
    test2();
    test3();
    return 0;
}

void test() {
    int *p; // int형 데이터를 가리키는 포인터 p
    int a;
    
    p = &a; // p에 a 메모리의 주소값(&)을 넣자

    printf("%p\n", p); // p의 값 = a의 주소
    printf("%p\n", &a); // 같은 값이 나온다
}
// 포인터는 특정한 데이터의 주소값을 보관
// 포인터는 주소값을 보관하는 데이터의 형에 * 붙임으로써 정의
// &연산자로 특정한 데이터의 메모리 상의 주소값을 알아올 수 있다

void test2() {
    int* p; // int 데이터를 가리키는 포인터 p
    int a; // int 변수 a

    p = &a; // 포인터 p에 a의 주소
    a = 2; // a에 2
    
    printf("%d\n", a);
    printf("%d\n", *p); // 저장된 주소값에 해당하는 데이터 *연산자
}

void test3() {
    int *p;
    int a;

    p = &a; // 포인터 p에 a의 주소
    *p = 3; // a = 3; 과 동일한 의미
    
    printf("%d\n", a);
    printf("%d\n", *p);
}

// 포인터 p는 *를 통해 a를 가리킬 수 있다
// 포인터 또한 엄연한 변수이기 때문에 특정한 메모리 공간을 차지한다.
// 따라서 포인터도 자기 자신만의 주소를 갖고 있다.

// 포인터 형이 필요한 이유는 포인터 p에 변수 a의 시작 주소가 들어있기 때문이다.
// 시작 주소 이후로 몇 개의 바이트를 더 읽어들어서 값을 변경해야 하는지 알려줘야하기 때문