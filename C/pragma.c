/* pragma
#pragma는 컴파일러엣게 말하는 전처리기 명령
#include나 #define처럼 전처리기에 의해 컴파일 이전에 처리되지만,
pragma 명령은 컴파일러에게 전달된다.

pragma는 C언어 기본 키워드라기 보다는, 컴파일러에 종속적인 키워드
문법이 컴파일러마다 다르고 통일되지 않았기 떄문
*/

#include <stdio.h>
#include "weird.h"
// #include "weird.h" // 두 번 정의하면 에러가 뜸!

// 처음 #include "weird.h"를 만났을 때, WEIRD_H가 정의되지 않았으므로 #ifndef WEIRD_H가 거짓이
// 되어 #endif 로 넘어가 여기에 내용이 복사가 안됨
// 이렇게 하면 헤더파일의 내용이 중복으로 포함되는 것을 막을 수 있다.

// #pragma once // once를 통해 한 번만 include 될 수 있다는 것을 말해주는데
// ifndef도가 간단명료, 컴파일 시간 절약
// 전처리기가 헤더파일을 열어보아서 WEIRD_H가 정의되었나 않았나 확인해봐야하는데
// once를 이용하면 다시 안열어봐도 되기 때문에 컴파일 시간 절약

// pragma 키워드는 컴파일러에게 전달되며
// pragma 키워드들은 컴파일러 종속적이여서 once 지원 안될 수도 있다.



#pragma pack(1) // 마이크로소프트 계열 컴파일러에게만 유효한 pragma // 1, 2, 4, 8, 16
// 구조체를 1바이트 단위로 정렬하라는 뜻
// #pragma pack(4) // 더블 워드 경계


int main() {
    Weird a;

    printf("size of a: %d \n", sizeof(a)); // 8
    // 6이 아닌 8이 나온다?! 실제 메모리 상에서 위의 구조체 크기를 8바이트로 컴파일러가 지정한다
    // 컴퓨터는 4바이트 단위로 처리하는 것이 빠르기 때문에, 데이터를 보관할 때 4의 배수로 보관
    // 이렇게 4의 배수 경계에 놓인 것을 double word 경계에 놓여있다라고 함
    // 불필요한 2바이트를 추가하면서까지 맞춘 것
    // 이렇게 하는 이유는 하드웨어 간의 통신 규격때문에 그렇다

    // 그런데!!!!
    // SCSI 인터페이스는 PC에서 하드디스크와 같은 주변 기기에 연결하기 위한 통신 방식으로
    // SCSI 장치들에게 읽기 명령을 내리기 위해 6바이트 명령어를 전송한다
    // 이 6바이트의 명령어 구조는 꽤 복잡해서 흔히 구조체로 많이 이용하는데
    // 위와 같이 그냥 사용했다가는 구조체의 크기가 8바이트로 설정되어 무슨 문제가 생기는지 알 수 없다!
    // 이렇게 컴파일러가 구조체를 더블 워드 경계에 놓지 말라고 하고 싶을 때 pragma 키워드를 사용

    a.i = 3;
    printf("a.i: %d \n", a.i);

    return 0;
}