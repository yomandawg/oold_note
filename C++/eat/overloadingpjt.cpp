// N차원 배열을 []를 이용해 원소에 접근하는 것을 구현하는 일은
// 상당한 수준의 아이디어가 필요하다!

// 기존의 C언어에서는 캐스팅은 2가지 방법
// 1. 컴파일러가 알아서 캐스팅 하는 암시적(implicit) 캐스팅
// 2. 지시하는 명시적(explicit) 캐스팅

// 암시적 캐스팅의 경우 int 와 double의 덧셈을 수행할 때,
// int 형 변수가 자동으로 double 변수로 캐스팅되는 것

// 명시적 캐스팅의 경우 예를 들어 void * 타입의 주소를 특정
// 구조체 포인터 타입의 주소로 바꾼다던지 등의 캐스팅

// 이 때, 명시적 캐스팅은 다음과 같이 수행
// ptr = (Something *)other_ptr;
// int_variable = (int)float_variable;
// 즉, 괄호 안에 원하는 타입을 넣고 변환을 수행한 것
// 하지만 이런 방식을 사용하다보면 문제점이 생긴다.
// 괄호에 타입을 넣는 방식으로 변환하는 탓에 가독성이 떨어짐
// function((int)variable); 와 같이 함수 호출에도 괄호를 사용하는데
// 너무 많아지게 되면 읽는 사람이나 코드를 유지보수하는 사람 입장에서
// 여러모로 불편하다. 하지만 또 다른 문제는 우리가 캐스팅하는
// 이유는 여러가지인데 C형식 캐스팅에서는 읽는이가 그 의미를
// 명확하게 알 수 없는 것!

// 이를 위해 C++은 4가지의 캐스팅을 제공한다.
// 1. static_casting : 흔히 생각하는 언어적 차원에서 지원하는 일반적 타입 변환
// 2. const_casting : 객체의 상수성(const)를 없애는 타입 변환. (const int => int)
// 3. dynamic_casting : 파생 클래스 사이에서의 다운 캐스팅
// 4. reinterpret_cast : 위험을 감수하고 하는 캐스팅으로 서로 관령니 없는 포인터들 사이의 캐스팅

// (원하는 캐스팅 종류)<바꾸려는 타입>(바꿀 것); 으로 선언
// static_cast<int>(float_variable);
// static_cast로 float 타입의 float_variable을 int 타입으로 변환
// C언어에서 (int)(float_varialbe)과 동일

// 사실 static_cast 말고 다른 캐스팅은 신경 안써도 되는데,
// 특별한 상황에서 적용해야 한다.



/* N차원 배열 만들기
사용자가 원하는 배열을 arr[x1][x2]...[xn]이라고 한다면,
x1 * x2 * ... * xn 크기의 1차원 배열을 할당한 뒤에
접근할 때 정확한 위치를 찾아주는 방법이다.
이러한 방식으로 구현한다면, 메모리도 정확히 필요한 만큼만
사용할 수 있기에 좋은 방법이다.

N차원 배열을 구현하는 프로젝트에서 사용할 아이디어는
이전에 2차원 배열의 동적 할당을 수행하면서 얻은 아이디어와 비슷
arr[x1][x2]

int** arr;
arr = new int*[x1];
for (int i = 0; i < x1; i++) arr[x1] new int[x2];

즉, 더블 포인터에 arr을 정의한 뒤, arr에 int*타입의 x1 크기의
1차원 배열을 먼저 할당한 다음, 이 int* 배열에 각 원소에 대해
또 x2 크기의 1차원 배열을 모두 할당한 것.

위와 같이 문어발 형식으로 맨 처음에는 x1 개의 int* 배열을 생성한 뒤,
각 int*에 대해 x2개의 int 배열을 만들게 된다면, 전체적으론 마치
int arr[x1][x2]를 한 것과 정확히 동일한 효과를 낸다.
하지만 이와 같은 방식의 문제점으로는 원래 int arr[x1][x2]를 하게
된다면 x1*x2 만큼 메모리를 잡아먹지만, 포인터 자체가 잡아먹는 크기 때문에
x1 * x2 + x1 + 1 만큼의 메모리를 잡아먹게 된다는 뜻!!!

하지만 위 방식의 좋은 점은, 메모리가 허용하는 한 크기가 매우 매우 큰 배열도
생성할 수 있다는 점.
첫 번째 방식의 경우 전체 배열의 원소 수가 int 크기를 넘어가게 된다면,
따로 큰 수의 정수를 다룰 수 있는 라이브러리를 사용해서 메모리를
동적으로 할당해주어야 한다. 하지만 이같은 N차원 배열 클래스에서
사용할 방식의 경우, 전체 원소 수가 아니라, 한 차원의 수가 int 크기만
넘어가지 않으면 된다. 다시 말해, (int 크기) * (int 크기) * ... * (int 크기) 개의 원소를
사용할 수 있으며, 아마 이는 충분할 것
3차원 배열의 경우, 가능한 최대 원소 개수가 2^96이나 된다!!

근데 또 문제점이 무엇이냐면, 우리가 만들어야 할 배열은 정해진
상수 차원의 배열이 아니라, N차원 배열이라는 것.
만일 3차원 배열을 만들었다면, int***를 이용할 것이고
4차원이면 int**** 등 너무 불편!

하지만 관점을 바꿔 생각하면 이는 포인터를 사용하는 것이
단순히 다음 레벨의 배열을 가리키기 위함이라면 굳이 N포인터를
사용하지 않고도 만들 수 있다!!
*/
struct Address {
    int level;
    void *next;
};
/*
이 생각을 바탕으로 하나의 작은 구조체를 만들어보면,
각각의 행들은 한 개의 레벨이라고 생각했을 때, 맨 처음에 우리가
정의하던 int**변수는 0레벨, 그 다음에 int**가 가리키던 int *
배열들은 1레벨, 그리고 실제 int 형 데이터가 들어있는 곳은 2레벨
이라고 생각할 수 있다. 그런데 Address 구조체를 도입한다면
굳이 int ** 등으로 귀찮게 할 필요 없이 모두 void * 포인터
하나로 정리할 수 있다.

이것이 어떻게 가능하냐면, top 이라는 Address 객체를 도입한다.
이 top은 위에서 맨 위의 레벨 0에 해당하며, next에는 레벨 1의
Adress 배열의 시작 주소가 들어간다. 그럼 이 top이 가리키고
있는 Adress 배열의 각각 원소들의 level은 당연히 1이 되겠고,
이들의 next는 int 배열의 시작 주소가 된다.(실질적 데이터)

여기서 좋은 점은 포인터라는 것이 타입에 상관없이 모두 void *
로 값을 보관할 수 있으므로 필요할 때만 적당한 포인터 타입으로
변환하면 된다. 정리하면 N차원 배열이라고 할 때 Address들은
총 0레벨부터 N - 1레벨까지 생성되며, N - 1레벨의 경우 next에
실제로 보관할 데이터에 해당하는 배열(여기서는 int)의 시작 주소값이
들어가게 되고, 나머지 0부터 N - 2 레벨까지는 그 다음 레벨의
Address 배열의 시작 주소값이 들어가게 된다.

이러한 레벨 방식을 도입해서 처리하는 이유는 각 레벨에서의 배열 크기가
모두 다를 수 있기 때문이다. 예를 들어,
arr[3][2][1]을 했을 경우, 1레벨의 크기가 3, 2레벨의 크기가 2
마지막 int 레벨 크기가 1이 된다.
 */

class Array {
    const int dim; // 몇 차원 배열인지
    int* size; // size[0] * size[1] * ... size[dim - 1] 짜리 배열

    struct Address {
        int level;
        // 맨 마지막 레벨(dim - 1 레벨)은 데이터 배열을 가리키고
        // 그 위 상위 레벨은 다음 Address 배열을 가리킴
        void* next;
    };
    Address* top;


    // address를 초기화하는 함수. 재귀 호출로 구성
    void initialize_address(Address *current) {
        if (!current) return;
        if (current->level == dim - 1) {
            current->next = new int[size[current->level]];
            return;
        }
        current->next = new Address[size[current->level]];
        for (int i = 0; i != size[current->level]; i++) {
            (static_cast<Address *>(current->next) + i)->level = current->level + 1;

            initialize_address(static_cast<Address *>(current->next) + i);
        }
    }
    // 위 initialize_address 함수는 인자로 들어온 current를 처리하고
    // 그 다음 단계로 넘어가도록 한다. 맨 처음의 if(!current) 부분은 단순히
    // current가 NULL일 때 예외적으로 처리하는 부분이므로 무시하고,
    // 두 번째 if 문은 앞에서 설명한 '종료 조건'이다. 이 재귀 호출이 끝나기
    // 위한 조건으로 현재 처리하고 있는 Address의 레벨이 dim - 1일 때, 이들의
    // next에는 Address 배열이 아닌 int 배ㅕ열의 시작 주소가 들어가게 된다.
    // 반면에 종료 조건에 해당되지 않는 경우 initialize_address함수에서 어떻게
    // 처리하냐면 current의 next에 크기가 size[current->level]인 새로운
    // 시작 주소값을 만들어준다. 이 때 왜 배열의 크기가 이와 같은지는 다음 차수이기
    // 때문이다. 예를 들어 arr[3][4][5]의 경우 current가 0레벨이면 next에 만드는
    // 배열의 크기는 3, 1레벨이라면 4, 2레벨이라면 5가 되는 것과 같은 이치
    // 이렇게 Address 배열을 만들게 된다면, 이 각각의 원소들에 대해서도 종료
    // 조건에 도달하기 전까지 동일한 처리를 계속 반복해줘야 한다. 따라서
    // for문으로 새롭게 생성한 각각의 원소에 대해 initialize_address를 수행한다.
    // 그 current의 next가 가리키고 있는 원소들의 레벨 값을 다음 단계로 설정한 다음
    // initialize_address를 각각의 원소들에 대해 호출한다.
    // 참고로 static_cast<Address *>(current->next) + i) 라는 표현은
    // current->next를 시작주소로 하는 Address 배열의 i번째 원소를 가리키는 포인터
    // 깊이우선탐색과 동일한 것

    // 생성자를 만들었으므로 소멸자도 비슷한 방식으로 만들면 된다.
    // 다만 소멸자의 경우 주의할 점이, 생성자는 위에서 아래로 메모리를 확장했지만
    // 소멸자는 아래에서 위로 메모리를 소멸해야한다.
    void delete_address(Address *current) {
        if (!current) return;
        for (int i = 0; current->level < dim - 1 && i < size[current->level]; i++) {
            delete_address(static_cast<Address *>(current->next) + i);
        }

        delete[] current->next;
    }

    public:
        Array(int dim, int* array_size) : dim(dim) {
            size = new int[dim];
            for (int i = 0; i < dim; i++) size[i] = array_size[i];

            top = new Address;
            top->level = 0;

            initialize_address(top);
        }
        Array(const Array& arr) : dim(arr.dim) {
            size = new int[dim];
            for (int i = 0; i < dim; i++) size[i] = arr.size[i];

            top = new Address;
            top->level = 0;

            initialize_address(top);
        }
        ~Array() {
            delete_address(top);
            delete[] size;
        }
        // 위 두개는 Array 기본 생성자와 복사 생성자, 그리고 소멸자를 나타낸 것
        // 재귀 함수의 시작으로 current에 top을 전달 후 함수들이 재귀 호출되면서
        // 거대한 N차원 메모리 구조가 생성되거나 소멸된다. 유의할 점은 소멸자에
        // 동적으로 할당ㅎ나 모든 것을 정리해 주어야 한다는 것인데, 재귀 호출로
        // 생성한 메모리 구조만을 소멸해야 하는 것이 아니라 size 역시 동적으로
        // 할당한 것이므로 꼭 해제해야 한다.

};
// 일단 중요한 정보로 몇차원 배열인지, 각 차원의 크기 정보를 포함
// dim이 아예 상수값으로 저장(차원을 정하면 바꿀 수 없게끔)
// 아니면 resize같은 함수 추가
// size 배열에 각 차원에 대한 정보를 갖게 했다.
// 그런데 바로 실질적 데이터를 보관하는 부분이 빠졌는데,
// 앞에서도 설명하였뜻이 거대한 N차원 배열은 마치 거대한
// 나무처럼 가느다란 줄기로부터 시작해서 엄청나게 큰 뿌리로
// 퍼지는 모습. 하지만 이 거대 배열을 가리키기 위해서 필요한
// 것은 단 하나, 바로 맨 상단의 시작점. 이 시작점은
// Address * 타입으로, 이를 top이라고 부르기로 했다.

// 재미있는 점은 클래스 안에도 클래스를 넣을 수 있다는 사실인데,
// 외부에서 우리 배열이 내부적으로 어떻게 작동하는지 공개하고
// 싶지 않고, 또 내부 정보에 접근하는 것을 원치 않기 때문에
// Array 안에 Address 구조체를 넣겠다.
// (참고로 c++에서 구조체는 모든 멤버 함수, 변수가 디폴트로
// public 인 클래스에 있다.)

// 그럼 본격적으로 top을 시작으로 N차원 배열을 생성해보면
// 이전에 동적으로 2차원 배열을 생성하였을 때처럼 for문으로
// 간단히 수행할 수 있는 것이 아니다. 왜냐면 for문으로 하기
// 위해서는 몇 중 for 문을 사용할지 컴파일 시에 정해져야 하는데,
// 이 경우 N차원인 임의의 차원이므로 그럴 수 없기 때문

// 이와 같은 문제를 해결하는 아주 좋은 아이디어가 바로 재귀함수
// 1. 함수에서 처리하는 것, 즉 현재 단계에서 다음 단계로 넘어가는 과정?
// 2. 재귀 호출이 종료되는 조건?

// 종료 조건은 바로 현재 처리하고 있는 Address 배열의 레벨이 (dim - 1)이면 된다.
// 즉, Address 배열의 레벨이 (dim - 1)이면 이 배열의 원소들 즉 (dim - 1)레벨들의
// Address들의 next에는 int 배열의 데이터가 들어가게 재귀 호출이 끝나게 된다.

// 그럼 다음 단계로 넘어가는 과정은 n레벨의 Adress 배열이라면 이들의
// next 에 다음 레벨인 n + 1레벨의 Address 배열을 지정해주고,
// 또 이 각각의 원소에 대해 처리하도록 하면 된다.


// 이제 생성을 했는데, 어떻게 원소에 접근하냐이다! 우리의 클래스는 다른
// 복잡한 방법을 사용하지 않고 마치 진짜 배열을 다루던 것처럼 []를 이용해
// 원소에 접근하고 싶다. 하지만 문제는 C++에는 1개의 []를 취하는 연산자는
// 있어도 N개의 []를 취하는 연산자는 없다..
// 그러면 arr[1][2][3][4]는 어떻게 처리하냐?
// 제일 먼저 arr[1]이 처리되며 첫 번째 차원으로 1을 선택했다는 정보가
// 담긴 객체 T를 리턴, 그리고 (T)[2][3][4]가 수행
// T 또한 operator[]가 있어서, 두 번째 차원으로 2를 선택했다는 정보가 담긴
// 객체 T'를 리턴한다. 그렇게 쭉 진행하면 T'''가 int타입일 것

// 일단 Array가 아닌 새로운 타입의 객체를 만들어야 한다는 것은 분명하다.
// 왜냐면 operator[]가 Array& 타입이면 1차원 Array 배열에 대해
// arr[1] = 3; 과 같은 문장은 말이 안되기 때문
// 그렇다고 해서 operator[] 가 int& 타입을 리턴할 수도 없는 처지
// int& 타입을 리턴하였을 경우 1차원 배열인 arr[1] = 3;과 같은 문장은
// 쉽게 처리할 수 있지만, 그보다 고차원 배열에 대해 arr[1][2] = 3;은
// 어떻게 처리할 것이냐? arr[1]의 리턴 타입이 int&라면 int에 대한
// operator[]은 정의되어 있지도 않고 정의할 수도 없다. 그렇다면
// 상황에 따라 1차원이면 int를, 그보다 고차원 배열이면 다른 것을 리턴하면?
// 오버로딩의 원칙 상 동일한 인자를 받는 함수에 대해서는 한가지 타입만 리턴 가능

// int 처럼 작동하지만 int가 아닌 클래스를 만들 수 있는데,
// 바로 int의 wrapper 클래스. 이는 타입 변환 연산자를 제공해서
// int와의 연산을 수행하거나, 대입 등을 할 때 마치 int처럼 작동하게
// 만들 수 있다. 그러면 우린 operator[]가 int의 wrapper 클래스 객체를
// 리턴해서, 실제 int값에 접근할 때는 int 변수처럼 행동하고, 위에서 T나
// T'처럼 원소에 접근해가는 중간 단계의 산물일 경우, 그 중간 단계의 정보를
// 포함하는 것으로 사용하면 됨

class Int {
    void* data;

    int level;
    Array* array;
}
// 먼저 level 정보는 반드시 포함사고 있어야한다. 왜냐면 이 Int가 맨 마지막
// 실제 int 정보를 포함하는 객체인지, 아니면 원소를 참조해가는 중간 과정의
// 산물인지 구별할 수 있어야 하기 때문
// 예를 들어 arr[1][2]; 를 보면 arr[1]은 level이 1인 Int가 리턴
// 이 때 int데이터가 아니라 [1][2]를 참조해 나가기 위한 중간 과정.
// 이것을 Int가 어떻게 구별하냐면, Int가 가지고 있는 array의 dim 정보 참조
// 이 때 Int는 현재 arr[1]을 가리키고 있음에 대한 정보가 Int의 data에 들어가
// 있다. 그 다음 Int의 operator[]를 수행하면 level 2인 Int가 리턴됨
// 사용자가 level 2인 Int에 대입 연산을 하게 된다면, void *data를 int원소를
// 가리키고 있는 주소로 해석해서 실제로 int 변수처럼 대입이 수행된다.
// 참고로 array는 어떤 배열의 Int 인지 가리키는 역할을 한다.