#include <iostream>

int main() {
    // int &ref = 4; // 오류
    // 상수값 자체는 리터럴이므로 상수이고
    // 따라서 위와 같이 레퍼런스로 참조하면
    // ref = 5;로 값을 바꿀 수 있는 여지가 생기기
    // 때문에 불가능(리터럴을 변경할 수 없다)
    // 즉, 상수 지정은 항상 리터럴로 한 것인데
    // &ref를 통해 리터럴을 참조하는 것 == 불가능

    const int &ref = 4; // 이 것은 가능
    // 왜냐면 ref값이 const이기 때문에
    // 변경 불가능하므로 참조값도 변경 불가능
    int a = ref; // 즉 이것은 a = 4;와 같은말

    std::cout << ref << std::endl;
}

// 레퍼런스의 배열이 과 연 가능한 것인가?!
// 레퍼런스는 정의와 함께 초기화시켜야함
int a, b;
// int& arr[2] = {a, b}; 불가능
// 레퍼런스의 포인터는 존재할 수 없다
// 레퍼런스는 메모리 상의 공간을 차지하는 것이 아니라
// 컴파일 시에 원래 레퍼런스가 참조하던 변수의 주소값으로
// 대체되는 것
// 따라서 메모리 공간을 차지하지 않는 것의 포인터는 말이 안됨

//즉 arr은 배열의 첫 번째 레퍼런스를 가리키는 포인터라는 말은 모순

int test() {
    int arr[3] = {1, 2, 3};
    int(&ref)[3] = arr; // ref가 arr을 가리키도록 한 것
    // 이와 같이 하면 ref[0]~ref[2]가 각각 arr[0]~arr[2]의
    // 레퍼런스가 되는 것
    // 배열의 레퍼런스는 잘 사용하지 않는데
    // 위와 같이 배열의 크기를 명시해야 하기 때문
    // int(&ref)[3]이라면 반드시 크기가 3인 int배열을 가리켜야 하고
    // int (&ref)[5]면 반드시 5크기의 int 배열을 가리켜야함

    // 하지만 포인터를 사용하면 굳이 그럴 필요 없이
    // 단순히 int *p 하나로 모든 1차원 배열들을 가리킬 수 있으니
    // 레퍼런스보단 포인트를 보통 사용

    ref[0] = 2;
    ref[1] = 3;
    ref[2] = 1;

    std::cout << arr[0] << arr[1] << arr[2] << std::endl;


    // 2차원 배열 ref
    int arr2[3][2] = {1, 2, 3, 4, 5, 6};
    int (&ref)[3][2] = arr2;

    return 0;
}



// int fnl(int &a) { return a; } 불가능
// ref로 임시로 복사된 x의 값(우측값)을 리턴

int &fn2(int &a) { return a; }
// ref인자를 받아서 다시 ref를 리턴함
// 즉 a는 x의 ref다! 라고 인식하고, 리턴할때
// x의 ref를 리턴함! 이라고 한다

int test2() {
    int x = 1;

    // std::cout << fnl(x)++ << std::endl;
    std::cout << fn2(x)++ << std::endl; // x의 값도 바뀜
    // 즉 이것은 x++와 같은 말이 됨
}